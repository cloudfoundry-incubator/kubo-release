// This file was generated by counterfeiter
package routefakes

import (
	"route-sync/route"
	"sync"

	"code.cloudfoundry.org/lager"
	cfconfig "code.cloudfoundry.org/route-registrar/config"
)

type FakeRouter struct {
	ConnectStub        func(natsServers []cfconfig.MessageBusServer, logger lager.Logger)
	connectMutex       sync.RWMutex
	connectArgsForCall []struct {
		natsServers []cfconfig.MessageBusServer
		logger      lager.Logger
	}
	TCPStub        func(routes []*route.TCP) error
	tCPMutex       sync.RWMutex
	tCPArgsForCall []struct {
		routes []*route.TCP
	}
	tCPReturns struct {
		result1 error
	}
	tCPReturnsOnCall map[int]struct {
		result1 error
	}
	HTTPStub        func(routes []*route.HTTP) error
	hTTPMutex       sync.RWMutex
	hTTPArgsForCall []struct {
		routes []*route.HTTP
	}
	hTTPReturns struct {
		result1 error
	}
	hTTPReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRouter) Connect(natsServers []cfconfig.MessageBusServer, logger lager.Logger) {
	var natsServersCopy []cfconfig.MessageBusServer
	if natsServers != nil {
		natsServersCopy = make([]cfconfig.MessageBusServer, len(natsServers))
		copy(natsServersCopy, natsServers)
	}
	fake.connectMutex.Lock()
	fake.connectArgsForCall = append(fake.connectArgsForCall, struct {
		natsServers []cfconfig.MessageBusServer
		logger      lager.Logger
	}{natsServersCopy, logger})
	fake.recordInvocation("Connect", []interface{}{natsServersCopy, logger})
	fake.connectMutex.Unlock()
	if fake.ConnectStub != nil {
		fake.ConnectStub(natsServers, logger)
	}
}

func (fake *FakeRouter) ConnectCallCount() int {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return len(fake.connectArgsForCall)
}

func (fake *FakeRouter) ConnectArgsForCall(i int) ([]cfconfig.MessageBusServer, lager.Logger) {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return fake.connectArgsForCall[i].natsServers, fake.connectArgsForCall[i].logger
}

func (fake *FakeRouter) TCP(routes []*route.TCP) error {
	var routesCopy []*route.TCP
	if routes != nil {
		routesCopy = make([]*route.TCP, len(routes))
		copy(routesCopy, routes)
	}
	fake.tCPMutex.Lock()
	ret, specificReturn := fake.tCPReturnsOnCall[len(fake.tCPArgsForCall)]
	fake.tCPArgsForCall = append(fake.tCPArgsForCall, struct {
		routes []*route.TCP
	}{routesCopy})
	fake.recordInvocation("TCP", []interface{}{routesCopy})
	fake.tCPMutex.Unlock()
	if fake.TCPStub != nil {
		return fake.TCPStub(routes)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.tCPReturns.result1
}

func (fake *FakeRouter) TCPCallCount() int {
	fake.tCPMutex.RLock()
	defer fake.tCPMutex.RUnlock()
	return len(fake.tCPArgsForCall)
}

func (fake *FakeRouter) TCPArgsForCall(i int) []*route.TCP {
	fake.tCPMutex.RLock()
	defer fake.tCPMutex.RUnlock()
	return fake.tCPArgsForCall[i].routes
}

func (fake *FakeRouter) TCPReturns(result1 error) {
	fake.TCPStub = nil
	fake.tCPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRouter) TCPReturnsOnCall(i int, result1 error) {
	fake.TCPStub = nil
	if fake.tCPReturnsOnCall == nil {
		fake.tCPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.tCPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRouter) HTTP(routes []*route.HTTP) error {
	var routesCopy []*route.HTTP
	if routes != nil {
		routesCopy = make([]*route.HTTP, len(routes))
		copy(routesCopy, routes)
	}
	fake.hTTPMutex.Lock()
	ret, specificReturn := fake.hTTPReturnsOnCall[len(fake.hTTPArgsForCall)]
	fake.hTTPArgsForCall = append(fake.hTTPArgsForCall, struct {
		routes []*route.HTTP
	}{routesCopy})
	fake.recordInvocation("HTTP", []interface{}{routesCopy})
	fake.hTTPMutex.Unlock()
	if fake.HTTPStub != nil {
		return fake.HTTPStub(routes)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hTTPReturns.result1
}

func (fake *FakeRouter) HTTPCallCount() int {
	fake.hTTPMutex.RLock()
	defer fake.hTTPMutex.RUnlock()
	return len(fake.hTTPArgsForCall)
}

func (fake *FakeRouter) HTTPArgsForCall(i int) []*route.HTTP {
	fake.hTTPMutex.RLock()
	defer fake.hTTPMutex.RUnlock()
	return fake.hTTPArgsForCall[i].routes
}

func (fake *FakeRouter) HTTPReturns(result1 error) {
	fake.HTTPStub = nil
	fake.hTTPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRouter) HTTPReturnsOnCall(i int, result1 error) {
	fake.HTTPStub = nil
	if fake.hTTPReturnsOnCall == nil {
		fake.hTTPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hTTPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRouter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	fake.tCPMutex.RLock()
	defer fake.tCPMutex.RUnlock()
	fake.hTTPMutex.RLock()
	defer fake.hTTPMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRouter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ route.Router = new(FakeRouter)
