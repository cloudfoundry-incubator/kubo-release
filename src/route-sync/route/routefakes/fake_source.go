// This file was generated by counterfeiter
package routefakes

import (
	"route-sync/route"
	"sync"
)

type FakeSource struct {
	TCPStub        func() ([]*route.TCP, error)
	tCPMutex       sync.RWMutex
	tCPArgsForCall []struct{}
	tCPReturns     struct {
		result1 []*route.TCP
		result2 error
	}
	tCPReturnsOnCall map[int]struct {
		result1 []*route.TCP
		result2 error
	}
	HTTPStub        func() ([]*route.HTTP, error)
	hTTPMutex       sync.RWMutex
	hTTPArgsForCall []struct{}
	hTTPReturns     struct {
		result1 []*route.HTTP
		result2 error
	}
	hTTPReturnsOnCall map[int]struct {
		result1 []*route.HTTP
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSource) TCP() ([]*route.TCP, error) {
	fake.tCPMutex.Lock()
	ret, specificReturn := fake.tCPReturnsOnCall[len(fake.tCPArgsForCall)]
	fake.tCPArgsForCall = append(fake.tCPArgsForCall, struct{}{})
	fake.recordInvocation("TCP", []interface{}{})
	fake.tCPMutex.Unlock()
	if fake.TCPStub != nil {
		return fake.TCPStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.tCPReturns.result1, fake.tCPReturns.result2
}

func (fake *FakeSource) TCPCallCount() int {
	fake.tCPMutex.RLock()
	defer fake.tCPMutex.RUnlock()
	return len(fake.tCPArgsForCall)
}

func (fake *FakeSource) TCPReturns(result1 []*route.TCP, result2 error) {
	fake.TCPStub = nil
	fake.tCPReturns = struct {
		result1 []*route.TCP
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) TCPReturnsOnCall(i int, result1 []*route.TCP, result2 error) {
	fake.TCPStub = nil
	if fake.tCPReturnsOnCall == nil {
		fake.tCPReturnsOnCall = make(map[int]struct {
			result1 []*route.TCP
			result2 error
		})
	}
	fake.tCPReturnsOnCall[i] = struct {
		result1 []*route.TCP
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) HTTP() ([]*route.HTTP, error) {
	fake.hTTPMutex.Lock()
	ret, specificReturn := fake.hTTPReturnsOnCall[len(fake.hTTPArgsForCall)]
	fake.hTTPArgsForCall = append(fake.hTTPArgsForCall, struct{}{})
	fake.recordInvocation("HTTP", []interface{}{})
	fake.hTTPMutex.Unlock()
	if fake.HTTPStub != nil {
		return fake.HTTPStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hTTPReturns.result1, fake.hTTPReturns.result2
}

func (fake *FakeSource) HTTPCallCount() int {
	fake.hTTPMutex.RLock()
	defer fake.hTTPMutex.RUnlock()
	return len(fake.hTTPArgsForCall)
}

func (fake *FakeSource) HTTPReturns(result1 []*route.HTTP, result2 error) {
	fake.HTTPStub = nil
	fake.hTTPReturns = struct {
		result1 []*route.HTTP
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) HTTPReturnsOnCall(i int, result1 []*route.HTTP, result2 error) {
	fake.HTTPStub = nil
	if fake.hTTPReturnsOnCall == nil {
		fake.hTTPReturnsOnCall = make(map[int]struct {
			result1 []*route.HTTP
			result2 error
		})
	}
	fake.hTTPReturnsOnCall[i] = struct {
		result1 []*route.HTTP
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.tCPMutex.RLock()
	defer fake.tCPMutex.RUnlock()
	fake.hTTPMutex.RLock()
	defer fake.hTTPMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeSource) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ route.Source = new(FakeSource)
